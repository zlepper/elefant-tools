use std::collections::HashMap;
use std::fs;
use elefant_client::{Oid, PostgresConnectionSettings, QueryResultSet};
use anyhow::Result;

#[tokio::main]
async fn main() -> Result<()> {
    let mut client = elefant_client::tokio_connection::new_client(PostgresConnectionSettings {
        database: "postgres".to_string(),
        host: "localhost".to_string(),
        password: "passw0rd".to_string(),
        user: "postgres".to_string(),
        port: 5416, // Postgres 16 for now
    }).await?;

    client.execute_non_query("drop database if exists type_codegen", &[]).await?;
    client.execute_non_query("create database type_codegen", &[]).await?;


    let mut client = elefant_client::tokio_connection::new_client(PostgresConnectionSettings {
        database: "type_codegen".to_string(),
        host: "localhost".to_string(),
        password: "passw0rd".to_string(),
        user: "postgres".to_string(),
        port: 5416, // Postgres 16 for now
    }).await?;


    let mut query_results = client.query(r#"select t.oid, t.typname::text, t.typdelim, t.typelem, t.typtype, t_elem.typarray = t.oid as is_array_type
from pg_catalog.pg_type t
         left join pg_catalog.pg_type t_elem on t.typelem = t_elem.oid
where t.typnamespace = 11
  and t.typrelid = 0
  and (t_elem.typrelid is null or t_elem.typrelid = 0)"#, &[]).await?;

    let mut types = HashMap::new();
    match query_results.next_result_set().await? {
        QueryResultSet::QueryProcessingComplete => {panic!("Results expected")}
        QueryResultSet::RowDescriptionReceived(mut row_reader) => {
            loop {
                match row_reader.next_row().await? {
                    None => break,
                    Some(row) => {
                        let postgres_type = PostgresType {
                            oid: row.get(0)?,
                            name: row.get(1)?,
                            delimiter: row.get(2)?,
                            element_oid: row.get(3)?,
                            typtype: row.get(4)?,
                            is_array_type: row.get::<Option<bool>>(5)?.unwrap_or(false),
                        };
                        types.insert(postgres_type.oid, postgres_type);
                    }
                }
            }
        }
    }


    let mut type_file_content = r#"// Autogenerated file - DO NOT EDIT
use crate::PostgresType;

impl PostgresType {
"#.to_string();


    let mut all_types: Vec<PostgresType> = types.values().cloned().collect();
    all_types.sort_by_key(|t| t.rust_constant_name());

    for typ in &all_types {

        type_file_content.push_str("\n    ");
        type_file_content.push_str("pub const ");
        type_file_content.push_str(&typ.rust_constant_name());
        type_file_content.push_str(": PostgresType = PostgresType {\n");
        type_file_content.push_str("        oid: ");
        type_file_content.push_str(&typ.oid.0.to_string());
        type_file_content.push_str(",\n");
        type_file_content.push_str("        name: \"");
        type_file_content.push_str(&typ.name);
        type_file_content.push_str("\",\n");
        type_file_content.push_str("        element: ");
        type_file_content.push_str(&if typ.element_oid.0 == 0 {
            "None".to_string()
        } else {
            let element_type = types.get(&typ.element_oid).unwrap();

            format!("Some(&PostgresType::{})", element_type.rust_constant_name())
        });
        type_file_content.push_str(",\n");
        type_file_content.push_str("        is_array: ");
        type_file_content.push_str(&typ.is_array_type.to_string());
        type_file_content.push_str(",\n");
        type_file_content.push_str("        array_delimiter: \"");
        type_file_content.push(typ.delimiter);
        type_file_content.push_str("\",\n");
        type_file_content.push_str("    };\n");
    }

    type_file_content.push_str("\n");
    type_file_content.push_str("    pub(crate) fn get_by_oid(oid: i32) -> Option<&'static PostgresType> {\n");
    type_file_content.push_str("        match oid {\n");
    for typ in &all_types {
        type_file_content.push_str("            ");
        type_file_content.push_str(&typ.oid.0.to_string());
        type_file_content.push_str(" => Some(&PostgresType::");
        type_file_content.push_str(&typ.rust_constant_name());
        type_file_content.push_str("),\n");
    }
    type_file_content.push_str("            _ => None,\n");
    type_file_content.push_str("        }\n");
    type_file_content.push_str("    }\n");


    type_file_content.push_str("}\n");

    fs::write("codegen/src/standard_types.rs", type_file_content)?;



    Ok(())
}

#[derive(Debug, Clone)]
struct PostgresType {
    oid: Oid,
    name: String,
    delimiter: char,
    element_oid: Oid,
    typtype: char,
    is_array_type: bool,
}

impl PostgresType {
    fn rust_constant_name(&self) -> String {
        if self.is_array_type {
            format!("{}_ARRAY", self.name.to_uppercase().trim_start_matches("_"))
        } else {
            self.name.to_uppercase()
        }
    }
}